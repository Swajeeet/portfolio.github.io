<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Portfolio of J Nithish, a passionate web developer skilled in web development, C++, Python, JavaScript, and algorithms."
    />
    <meta
      name="keywords"
      content="J Nithish, portfolio, web developer, DAA project, KLE Technological University"
    />
    <meta name="author" content="J Nithish" />
    <meta
      property="og:title"
      content="J Nithish - Web Developer Portfolio"
    />
    <meta
      property="og:description"
      content="Explore my skills, projects, and contact details."
    />
    <title>Nithish - Reflections</title>

    <!-- Font Awesome icons -->
    <script
      src="https://kit.fontawesome.com/a9cdbedf57.js"
      crossorigin="anonymous"
    ></script>

    <!-- Styling CSS -->
    <link rel="stylesheet" id="themeStylesheet" href="./style.css" />

    <!-- External Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <header>
      <div>
        <h2 class="hero-section__desc"><span>Course Project</span></h2>
      </div>
    </header>

    <main>
   <!-- DAA Lab Reflections -->
      <section class="about-section" id="about">
        <div class="about-content">
          <h2 class="title">DAA Lab Reflections</h2>

          <!-- Key Concepts Learned -->
          <h3>Key Concepts Learned</h3>
          <ul>
            <li>Time Complexity Analysis</li>
            <li>Binary Search Tree</li>
            <li>DFS and BFS</li>
            <li>Heap</li>
            <li>Sorting</li>
            <li>Pattern Searching</li>
            <li>Graph Algorithms</li>
          </ul>

          <!-- Challenges -->
          <h3>1. Challenges in Learning/Understanding the Above Concepts</h3>
          <ul>
            <li>
              <b>Time Complexity Analysis:</b> Requires a deep understanding of
              mathematical notations like Big-O, Theta, and Omega.
            </li>
            <li>
              <b>Binary Search Tree:</b> Difficulty in understanding rotations
              during insertion and deletion operations.
            </li>
            <li>
              <b>DFS and BFS:</b> Requires grasping recursion for DFS and
              queue-based implementation for BFS.
            </li>
            <li>
              <b>Heap:</b> Understanding the heapify process and its application
              in priority queues.
            </li>
            <li>
              <b>Sorting:</b> Choosing between algorithms like QuickSort,
              MergeSort, or HeapSort for optimal performance.
            </li>
            <li>
              <b>Pattern Searching:</b> Challenges in implementing algorithms
              like KMP due to preprocessing requirements.
            </li>
            <li>
              <b>Graph Algorithms:</b> Modeling real-world problems and
              understanding shortest path or MST algorithms.
            </li>
          </ul>

          <h3>2. Challenges in Correlating with Real-World Applications</h3>
          <ul>
            <li>
              <b>Time Complexity Analysis:</b> Applying theoretical efficiency
              to large-scale systems like web servers.
            </li>
            <li>
              <b>Binary Search Tree:</b> Optimizing database search operations
              using balanced trees like AVL or Red-Black Trees.
            </li>
            <li>
              <b>DFS and BFS:</b> Using these in navigation systems or solving
              puzzles like mazes.
            </li>
            <li>
              <b>Heap:</b> Applications in job scheduling or real-time priority
              management.
            </li>
            <li>
              <b>Sorting:</b> Efficiently handling data in e-commerce platforms
              or search engines.
            </li>
            <li>
              <b>Pattern Searching:</b> Real-world applications in text editors
              or DNA sequence analysis.
            </li>
            <li>
              <b>Graph Algorithms:</b> Applications in social networks,
              logistics, and communication networks.
            </li>
          </ul>
          
          <h3>3. Determining the Most Efficient Approach/Design Techniques</h3>
          <ul>
            <li>
              <b>Time Complexity Analysis:</b> Start with brute force and
              optimize incrementally by analyzing time complexity.
            </li>
            <li>
              <b>Binary Search Tree:</b> Use AVL or Red-Black Trees for balanced
              data storage and retrieval.
              <pre>
                void insert(Node*& root, int value) {
                if (root == nullptr) {
                root = new Node(value);
                return;
                }
                if (value < root->data) {
                  insert(root->left, value);
                  }
                  else {
                  insert(root->right, value);
                  }
                  root = balance(root);
                  }
              </pre>
            </li>
            <li>
              <b>DFS and BFS:</b> Choose DFS for pathfinding problems and BFS
              for shortest path in unweighted graphs.
              <pre>
                void BFS(Graph& g, int start) {
                queue q;
                vector visited(g.size(), false);
                q.push(start);
                visited[start] = true;
                while (!q.empty()) {
                int node = q.front();
                q.pop();
                cout << node << " ";
                  for (int neighbor : g[node]) {
                  if (!visited[neighbor]) {
                  q.push(neighbor);
                  visited[neighbor] = true;
                  }
                  }
                  }
                  }
                </pre>
            </li>
                  <li>
                    <b>Heap:</b> Use heaps for implementing efficient priority queues.
                    <pre>
                      void heapify(vector& heap, int n, int i) {
                      int largest = i;
                      int left = 2 * i + 1;
                      int right = 2 * i + 2;
                      if (left < n && heap[left] > heap[largest])
                        largest = left;
                        if (right < n && heap[right] > heap[largest])
                          largest = right;
                          if (largest != i) {
                          swap(heap[i], heap[largest]);
                          heapify(heap, n, largest);
                          }
                          }
                        </pre>
                  </li>
                          <li>
                            <b>Sorting:</b> Use MergeSort for stability, QuickSort for in-place sorting, and HeapSort for space efficiency.
                            <pre>
                              void quickSort(vector& arr, int low, int high) {
                              if (low < high) {
                              int pi = partition(arr, low, high);
                              quickSort(arr, low, pi - 1);
                              quickSort(arr, pi + 1, high);
                              }
                              }
                            </pre>
                          </li>
                                <li>
                                  <b>Pattern Searching:</b> Apply KMP or Rabin-Karp for pattern matching in large datasets efficiently.
                                  <pre>
                                    void computeLPSArray(string pattern, int M, int* lps) {
                                    int len = 0;
                                    lps[0] = 0;
                                    int i = 1;
                                    while (i < M) {
                                    if (pattern[i] == pattern[len]) {
                                    len++;
                                    lps[i] = len;
                                    i++;
                                    }
                                    else {
                                    if (len != 0) {
                                    len = lps[len - 1];
                                    }
                                    else {
                                    lps[i] = 0;
                                    i++;
                                    }
                                    }
                                    }
                                    }
                                  </pre>
                                </li>
                                      <li>
                                        <b>Graph Algorithms:</b> Use Dijkstra for shortest paths, Prim or Kruskal for MST, and Bellman-Ford for graphs with negative weights.
                                        <pre>
                                          void dijkstra(vector>>& graph, int src) {
                                          priority_queue, vector>, greater>> pq;
                                          vector dist(graph.size(), INT_MAX);
                                          pq.push({0, src});
                                          dist[src] = 0;
                                          while (!pq.empty()) {
                                          int u = pq.top().second;
                                          pq.pop();
                                          for (auto& neighbor : graph[u]) {
                                          int v = neighbor.first;
                                          int weight = neighbor.second;
                                          if (dist[u] + weight < dist[v]) {
                                          dist[v] = dist[u] + weight;
                                          pq.push({dist[v], v});
                                          }
                                          }
                                          }
                                          }
                                        </pre>
                                      </li>
         </ul>
        </div>

        <div class="about-content">
          <h2 class="title">DAA Theory Reflections</h2>
          <ol>
                <li>
                    What are the kinds of problems we see in nature? (iteration, recursion, backtracking)
                    <p class="ans">
                        Nature presents numerous complex problems, many of which can be solved through computational techniques.
                        The life cycle and food chain are examples of processes that can be modeled using recursion.
                        <br>
                        Predicting climate change, on the other hand, is best tackled with iteration due to its dynamic, evolving patterns.
                         Bees, using backtracking, efficiently find the optimal foraging paths, ensuring maximum resource acquisition.
                        <br>
                        Similarly, plants exhibit self-organizing behavior, adjusting their growth patterns through backtracking to maximize sun exposure.
                        These natural processes, when modeled computationally, provide valuable insights into optimization and problem-solving techniques in real-world applications.
                        <br>
                        </p>
                </li>
                <li>
                    What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.
                    <p class="ans">
                        Space and time efficiency refer to how much memory it uses as the input size grows and how fast an algorithm runs. 
                        Time efficiency ensures the program runs quickly, while space efficiency focuses on saving memory, which is especially important in resource-limited environments. 
                        The different class of problem can be represented in form of graph as follows:
                        <br>
                            O(1): constant order of growth 
                        <br>
                            O(n): linear order of growth 
                        <br>
                            O(log n): logarithmic order of growth 
                        <br>
                            O(nlogn): Runtime increases more than linear but less than quadratic with input size.
                        <br>
                            O(n2): Runtime increases quadratically.
                        <br>
                            O(n3): Runtime increases cubic.
                        <br>
                            O(2^n): The runtime grows exponentially.
                        <br>
                            O(n!): The runtime grows extremely fast.
                    </p>
                </li>
                <li>
                    Take away from different design principles from chapter 2?
                    <p class="ans">
                        The key takeaway from the design principles is how simple strategies can make complex problems more manageable and algorithms more efficient. 
                        By using principles like decomposition, pattern recognition, and abstraction, we break down tasks into smaller parts. 
                        Techniques like pruning (in N-queens) and lazy propagation (in segment trees) optimize resource use, eliminating unnecessary steps or delaying updates until needed. 
                        Hierarchical order (in BST) and level order traversal (in BFS) help us process data effectively. 
                        Pre-computing results, like in lookup tables, simplifies repeated operations. 
                        Using parental dominance in heaps and bit manipulation in Fenwick trees speeds up calculations. 
                        Finally, DFS and BFS teach us to navigate graphs with careful traversal. 
                        All these principles combine to create more efficient algorithms.
                    </p>
                </li>
                <li>
                    The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
                    <p class="ans">
                        Tree data structures are essential for organizing hierarchical data and optimizing operations like searching, sorting, and indexing. 
                        A general tree provides flexibility for generic hierarchies but lacks efficiency. 
                        Binary trees are foundational but can become inefficient if unbalanced. 
                        Self-balancing trees like AVL and Red-Black trees ensure \(O(\log n)\) operations, with AVL trees being more strictly balanced and Red-Black trees easier to maintain during frequent updates. 
                        Heaps are ideal for priority-based tasks (e.g., scheduling), while Tries excel in prefix searches and string operations, such as autocompletion. 
                        Multiway trees like 2-3 trees offer consistent balancing, making them perfect for databases and file systems. 
                        Each structure is tailored to specific scenarios, balancing trade-offs between speed, complexity, and memory usage.
                    </p>
                </li>
                <li>
                    The need for array query algorithms and their implications. Their applications and principles need to be discussed.
                    <p class="ans">
                       Array query algorithms are essential for efficiently searching, updating, and querying elements in an array, especially when dealing with large datasets. These algorithms are crucial for accessing data within specific intervals and ensuring quick responses for range-based queries.
                        <br>
                        Lookup Tables: A lookup table is a data structure used to efficiently answer range queries in a dataset. It pre-computes values such as minimum, maximum, or sum for various intervals. By storing these results, lookup tables save computation time during repeated queries, utilizing the concept of pre-computing for faster access.
                        <br>
                        Segment Trees: Segment trees divide an array into segments and represent it as a binary tree using a bottom-up approach. They are particularly effective for range queries and updates. Segment trees utilize the principle of lazy propagation, storing changes and only applying them when needed, optimizing performance and reducing unnecessary updates.
                        <br>
                        Sparse Tables: Sparse tables are designed for fast querying of static data. They preprocess the data, allowing for efficient range queries, particularly useful for minimum or maximum queries on immutable datasets. The preprocessing ensures that subsequent queries can be answered in constant time.
                        <br>Fenwick Trees (Binary Indexed Trees): Fenwick trees are used for efficient computation of cumulative sums, minimums, or maximums over ranges of elements. Each node in a Fenwick tree stores information about a specific range, enabling fast updates and queries. The core principle used is bit manipulation, which helps in efficiently navigating the tree structure for quick computations</p>
                        </p>
                </li>
                <li>
                    Differentiate between tree and graphs and their traversals. The applications of each.
                    <p class="ans">
                        Tree <br>
                        -A connected, acyclic graph with n nodes and n-1 edges. <br>
                        -always has a root node. <br>
                        -always connected. <br>
                        -no cycles. <br>
                        
                       <br> Graphs <br>
                        -Collection of vertices connected by edges, cyclic and even disconnected. <br>
                        -no specific root unless mentioned. <br>
                        -can be connected or disconnected. <br>
                        -have cycles. <br>
                        
                        <br> Tree traversals <br>
                        1. Pre order: Root,Left,Right <br>
                        2. In order: Left, Root, Right <br>
                        3. Post order: Left, Right, Root <br>
                        <br> Eg: heap, BST for search, insert, delete <br>
                        
                        <br> Graph Traversals <br>
                       <br> DFS: traverse as deep as possible before backtracking. <br>
                         Eg: Road maps, Invitation problem. <br>
                        
                       <br> BFS: visit all neighbour nodes before moving. <br>
                        Eg: Networks (social networks)
                    </p>
                </li>
                <li>
                    Deliberate on sorting and searching algorithms, the technique behind each and how they connect to the real world.
                    <p class="ans">
                      Sorting and searching algorithms are essential for efficiently managing and retrieving data.
                        <br>
                        ->Sorting Algorithms:
                        <br>
                        ⸳Bubble Sort: Compares and swaps adjacent elements, but is inefficient for large datasets.
                        <br>
                        ⸳Selection Sort: Improves on bubble sort by swapping only the minimum element in each pass.
                        <br>
                        ⸳Insertion Sort: Inserts elements in the correct position, effective for small or partially sorted data.
                        <br>
                        ⸳Merge Sort and Quick Sort: Both use the divide-and-conquer principle, dividing data into smaller parts and sorting them, offering better efficiency with O(n log n) time complexity.
                        <br>
                        ⸳Heap Sort: Builds a heap and sorts by repeatedly extracting the maximum or minimum element, also with O(n log n) time complexity.
                        <br>
                        ->Searching Algorithms:
                        <br>
                        ⸳Linear Search: Checks each element sequentially, suitable for unsorted or small datasets.
                        <br>
                        ⸳Binary Search: Efficiently searches sorted data by dividing the dataset in half, with a time complexity of O(log n).
                        <br>
                        ->Real-World Applications:
                        Sorting and searching algorithms are used in various applications like sorting product listings, 
                        ranking search results, filtering preferences, and quickly retrieving information from large datasets, such as in e-commerce platforms, search engines, and data analysis.
                    </p>
                </li>
                <li>
                    Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.
                    <p class="ans">
                        Graph algorithms, especially for spanning trees and shortest paths, are essential for optimizing real-world systems like networks, navigation, and logistics. 
                        Spanning tree algorithms help efficiently connect all nodes with minimal cost, making them crucial for network design and broadcasting. 
                        Shortest path algorithms, like Dijkstra’s, are used to find the fastest or most cost-effective route, impacting applications like GPS navigation, data routing, and supply chain management. 
                        Together, these algorithms ensure efficient and cost-effective connectivity in fields like telecommunications, transportation, and resource management.
                    </p>
                </li>
                <li>
                    Discuss the different studied algorithm design techniques.
                    <p class="ans">
                        In class, we first learned about the design technique of backtracking, which involves solving problems like the N-Queens problem and subset generation. We explore all possible solutions and eliminate those that aren’t needed. 
                        Along with this, we studied transform and conquer, where we learned about data structures like AVL trees, heaps, and 2-3 trees that help in optimizing solutions.
                        <br>
                        Next, we encountered the decrease and conquer technique, especially in graph traversal. There are two main ways to traverse a graph:
                        <br>
                        -Breadth-First Search (BFS), where we visit all the nodes directly connected to the source first and then move on to the next level of nodes.
                        <br>
                        -Depth-First Search (DFS), where we explore one path fully before backtracking to explore other paths.
                        <br>
                        We also looked at divide and conquer in sorting algorithms, where we break the problem into smaller parts, solve each, and then combine the results. In string matching, we explored design principles like brute-force, hashing, and algorithms like Boyer-Moore, which balance space and time efficiently. 
                        Finally, we studied greedy algorithms, such as Prim’s, Kruskal’s, and Dijkstra’s, to find the shortest path in a weighted graph.
                        <br>
                        This approach simplifies complex problems by breaking them down into manageable parts and choosing the most efficient solutions.
                       </p>
                </li>
            </ol>
        </div>

      </section>
      </main>
    <!-- Footer -->
    <footer>
      <p>
        Copyright &copy; <span id="year"></span>
        <a href="https://github.com/nithish_213" target="_blank" rel="noopener"
          >Swajeet Chikhali</a
        >
        - All Rights Reserved.
      </p>
    </footer>

    <!-- JavaScript -->
    <script src="./script.js"></script>
  </body>
</html>
