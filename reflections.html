<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Portfolio of Swajeet Chikhali, As a student passionate about technology and problem-solving, I'm developing skills to create innovative solutions. 
                                                  My coursework and projects focus on practical application and effective problem resolution."
    />
    <meta
      name="keywords"
      content="Swajeet Chikhali, portfolio, web developer, DAA project, KLE Technological University"
    />
    <meta name="author" content="Swajeet Chikhali" />
    <meta
      property="og:title"
      content="Swajeet Chikhali - Web Developer Portfolio"
    />
    <meta
      property="og:description"
      content="Explore my skills, projects, and contact details."
    />
    <title>Swajeet Chikhali - Reflections</title>

    <!-- Font Awesome icons -->
    <script
      src="https://kit.fontawesome.com/a9cdbedf57.js"
      crossorigin="anonymous"
    ></script>

    <!-- Styling CSS -->
    <link rel="stylesheet" id="themeStylesheet" href="./style.css" />

    <!-- External Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <header>
      <div>
        <h2 class="hero-section__desc"><span>Course Project</span></h2>
      </div>
    </header>

    <main>
   <!-- Learning Reference -->
     <section class="about-section" id="about">
        <div class="about-content">
        <h2 class="title" >My Learning References</h2>
          <h3>Challenges:</h3>
          <h4>1. Challenges in Learning/Understanding the Above Concepts:</h4>
          <p>
            Understanding topics like time complexity, binary search trees, and graph algorithms can be difficult due to their abstract nature and real-world applications. Concepts such as DFS, BFS, and heaps require a strong grasp of recursion and data structures, making visualization and building intuition challenging. 
            By focusing on hands-on examples and breaking down each concept step by step, these complex topics become more accessible and easier to comprehend.
          </p>
          <h4>2. Challenges in Correlating with Real-World Applications:</h4>
          <p>
            Connecting these concepts to real-world problems requires bridging theoretical knowledge with practical use. For instance, understanding how graph algorithms optimize logistics routes or how pattern searching aids in text analysis
            for search engines can seem abstract without hands-on projects or real-world case studies to showcase their relevance and application.
          </p>
          <h4>3. Determining the Most Efficient Approach/Design Techniques for Solving a Complex Problem:</h4>
          <p>
            Selecting the optimal approach involves weighing trade-offs between time and space complexity, analyzing problem constraints, and testing various algorithms. 
            It requires strong analytical skills, a deep understanding of the problem, and often iterative adjustments to enhance performance.
          </p>
        </div>
     </section>

      <section class="Reflection">
        <h2>Course  Learning Reflections</h2>
        <div class="reflection-box">
            <ol>
                <li>
                    What are the kinds of problems we see in nature? (iteration, recursion, backtracking)
                    <p class="ans">
                       <br>Nature presents numerous complex problems, many of which can be solved through computational techniques.
                        The life cycle and food chain are examples of processes that can be modeled using recursion.
                        <br>
                        Predicting climate change, on the other hand, is best tackled with iteration due to its dynamic, evolving patterns.
                         Bees, using backtracking, efficiently find the optimal foraging paths, ensuring maximum resource acquisition.
                        <br>
                        Similarly, plants exhibit self-organizing behavior, adjusting their growth patterns through backtracking to maximize sun exposure.
                        These natural processes, when modeled computationally, provide valuable insights into optimization and problem-solving techniques in real-world applications.
                    </p>
                </li>
                <li>
                    What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth.
                    <p class="ans">
                        <br>
                        Time efficiency refers to how quickly an algorithm executes, while space efficiency measures the additional memory required during execution. Time efficiency is crucial in real-world applications, where faster algorithms are preferred. Space efficiency ensures optimal resource utilization, maximizing performance with minimal resources. 
                        <br>
                        - **O(1)**: Constant time complexity.
                        <br>
                            - **O(n)**: Linear time complexity.
                        <br>
                            - **O(log n)**: Logarithmic time complexity.
                        <br>
                            - **O(n log n)**: Slightly more than linear time, less than quadratic.
                        <br> 
                            -**O(n²)**: Quadratic time complexity.
                        <br>
                            - **O(n³)**: Cubic time complexity.
                        <br>
                            - **O(2^n)**: Exponential time complexity.
                        <br>
                            - **O(n!)**: Factorial time complexity, grows extremely fast.
                    </p>
                </li>
                <li>
                    Take away from different design principles from chapter 2?
                    <p class="ans"> 
                    <br>
                        The key takeaway from design principles is how simple concepts simplify complex problems, making algorithms more efficient.
                        We break down problems using decomposition, pattern recognition, and abstraction to manage tasks effectively. 
                    <br>
                        Pruning (used in N-queens) and lazy propagation (used in segment trees) optimize resource usage. Pruning eliminates non-viable solutions, while lazy propagation delays updates until necessary. 
                    Hierarchical order (BST) and level-order traversal (BFS) aid in data processing. Pre-computing (lookup tables) simplifies problems by storing results of frequent operations. 
                    <br>
                    Heaps use parental dominance to maintain efficiency. Bit manipulation (Fenwick tree) speeds up computations. DFS and BFS implement brave and cautious traversal for effective graph navigation. Overall, these principles create efficient algorithms.
                </li>
                <li>
                    The hierarchical data and how different tree data structures solve and optimize over problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
                    <p class="ans">
                        <br>
                        A binary search tree efficiently supports operations like searching and insertion. 2-3 trees maintain balanced depth, ensuring optimal performance. AVL trees are self-balancing, automatically adjusting to maintain balance during insertions and deletions. 
                        Red-black trees balance themselves using color coding, ensuring efficient operations. Heaps maintain parental dominance, making deletions quick and efficient.
                        <br>
                        Tries optimize search performance by using prefix-based searches, enabling fast lookups in applications like autocomplete and dictionary searches. 
                        Each of these data structures offers unique advantages, contributing to the overall efficiency and effectiveness of algorithmic solutions.
                </li>
                <li>
                    The need for array query algorithms and their implications. Their applications and principles need to be discussed.
                    <p class="ans">
                        <br>
                        Array query algorithms are essential for efficiently searching, updating, and querying elements in an array, especially when dealing with large datasets. These algorithms are crucial for accessing data within specific intervals and ensuring quick responses for range-based queries.
                        <br>
                        Lookup Tables: A lookup table is a data structure used to efficiently answer range queries in a dataset. It pre-computes values such as minimum, maximum, or sum for various intervals. By storing these results, lookup tables save computation time during repeated queries, utilizing the concept of pre-computing for faster access.
                        <br>
                        Segment Trees: Segment trees divide an array into segments and represent it as a binary tree using a bottom-up approach. They are particularly effective for range queries and updates. Segment trees utilize the principle of lazy propagation, storing changes and only applying them when needed, optimizing performance and reducing unnecessary updates.
                        <br>
                        Sparse Tables: Sparse tables are designed for fast querying of static data. They preprocess the data, allowing for efficient range queries, particularly useful for minimum or maximum queries on immutable datasets. The preprocessing ensures that subsequent queries can be answered in constant time.
                        <br>
                        Fenwick Trees (Binary Indexed Trees): Fenwick trees are used for efficient computation of cumulative sums, minimums, or maximums over ranges of elements. Each node in a Fenwick tree stores information about a specific range, enabling fast updates and queries. The core principle used is bit manipulation, which helps in efficiently navigating the tree structure for quick computations</p>
                </li>
                <li>
                    Differentiate between tree and graphs and their traversals. The applications of each.
                    <p class="ans">
                        Trees and graphs are data structures that organize data differently. A tree is a hierarchical structure with a single root and no cycles, ideal for representing relationships like family trees or organizational charts. 
                        A graph consists of nodes connected by edges and can have cycles, making it suitable for networks, social connections, or road maps.
                        <br>
                        ->Tree Traversal:
                        <br>
                        1. Pre-order: Visit the root node first, then traverse the left subtree, followed by the right subtree.
                        <br>
                        2. In-order: Traverse the left subtree first, then visit the root node, and finally, traverse the right subtree.
                        <br>
                        3. Post-order: Traverse the left subtree first, then the right subtree, and visit the root node last.
                        <br>
                        ->Graph Traversal:
                        <br>
                        1. DFS (Depth First Search): A "brave" traversal method that explores as far down a branch as possible before backtracking.
                        <br>
                        2. BFS (Breadth First Search): A "cautious" traversal method that explores all neighbors of a node before moving to the next level.
                        <br>
                        ->Applications of Trees and Graphs:
                        <br>
                        1. Trees: Used for representing hierarchical data, such as file systems, organizational charts, and decision trees. They are also efficient for searching and sorting (e.g., binary search trees).
                        <br>
                        2. Graphs: Ideal for applications that require finding the shortest path, such as network routing, social media connections, or transportation maps. Graph algorithms like Dijkstra’s or A* are commonly used to solve pathfinding problems.
                </li>
                <li>
                    Deliberate on sorting and searching algorithms, the technique behind each and how they connect to the real world.
                    <p class="ans">
                        Sorting and searching algorithms are essential for efficiently managing and retrieving data.
                        <br>
                        ->Sorting Algorithms:
                        <br>
                        ⸳Bubble Sort: Compares and swaps adjacent elements, but is inefficient for large datasets.
                        <br>
                        ⸳Selection Sort: Improves on bubble sort by swapping only the minimum element in each pass.
                        <br>
                        ⸳Insertion Sort: Inserts elements in the correct position, effective for small or partially sorted data.
                        <br>
                        ⸳Merge Sort and Quick Sort: Both use the divide-and-conquer principle, dividing data into smaller parts and sorting them, offering better efficiency with O(n log n) time complexity.
                        <br>
                        ⸳Heap Sort: Builds a heap and sorts by repeatedly extracting the maximum or minimum element, also with O(n log n) time complexity.
                        <br>
                        ->Searching Algorithms:
                        <br>
                        ⸳Linear Search: Checks each element sequentially, suitable for unsorted or small datasets.
                        <br>
                        ⸳Binary Search: Efficiently searches sorted data by dividing the dataset in half, with a time complexity of O(log n).
                        <br>
                        ->Real-World Applications:
                        Sorting and searching algorithms are used in various applications like sorting product listings, ranking search results, filtering preferences, and quickly retrieving information from large datasets, such as in e-commerce platforms, search engines, and data analysis.
                </li>
                <li>
                    Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.
                    <p class="ans">
                        Graph algorithms are essential for solving optimization problems, especially when it comes to minimizing traversal costs. Algorithms like Kruskal's and Prim's are used to find the minimum spanning tree, which reduces the cost of traversal. 
                        These are applied in real-world scenarios such as laying cables, pipelines, and developing networks. For navigating the shortest path, algorithms like Dijkstra's and Floyd-Warshall are used, which are crucial for network routing, mapping, and navigation. 
                        By leveraging spanning trees and shortest path algorithms, we can enhance efficiency and reduce costs in various applications.
                </li>
                <li>
                    Discuss the different studied algorithm design techniques.
                    <p class="ans">
                        In class, we first learned about the design technique of backtracking, which involves solving problems like the N-Queens problem and subset generation. We explore all possible solutions and eliminate those that aren’t needed. 
                        Along with this, we studied transform and conquer, where we learned about data structures like AVL trees, heaps, and 2-3 trees that help in optimizing solutions.
                        <br>
                        Next, we encountered the decrease and conquer technique, especially in graph traversal. There are two main ways to traverse a graph:
                        <br>
                        -Breadth-First Search (BFS), where we visit all the nodes directly connected to the source first and then move on to the next level of nodes.
                        <br>
                        -Depth-First Search (DFS), where we explore one path fully before backtracking to explore other paths.
                        <br>
                        We also looked at divide and conquer in sorting algorithms, where we break the problem into smaller parts, solve each, and then combine the results. In string matching, we explored design principles like brute-force, hashing, and algorithms like Boyer-Moore, which balance space and time efficiently. 
                        Finally, we studied greedy algorithms, such as Prim’s, Kruskal’s, and Dijkstra’s, to find the shortest path in a weighted graph.
                        <br>
                        This approach simplifies complex problems by breaking them down into manageable parts and choosing the most efficient solutions.
                </li>
            </ol>
        </div>
    </section>
    <!-- Footer -->
    <footer>
      <p>
        Copyright &copy; <span id="year"></span>
        <a href="https://github.com/Swajeeet" target="_blank" rel="noopener"
          >Swajeet Chikhali</a
        >
        - All Rights Reserved.
      </p>
    </footer>

    <!-- JavaScript -->
    <script src="./script.js"></script>
  </body>
</html>
